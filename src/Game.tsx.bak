import React, { useRef, useEffect } from 'react';
import InputManager from './input';
import { createPlayer, Player, PHYS, PLAYER_DEFAULTS } from './player';
import { LEVELS } from './levels';
import assetManager from './assetManager';
import audioManager from './audioManager';
import { ParallaxLayer } from './parallax';
import EffectsManager from './effects';
import { getHeightAtX } from './heightmap';
import { validateLevel } from './level';
import { startEditor } from './editor';
import {
  VIRTUAL_WIDTH,
  VIRTUAL_HEIGHT,
  CAMERA_SETTINGS,
  FIXED_DT
} from './game/constants';
import {
  GameState,
  GameContext,
  Camera
} from './game/types';
import { createSnowPattern, createNoisePattern } from './game/patterns';
import { simulate } from './game/simulation';
import { draw } from './game/renderer';
import { loadLevelAssets, loadLevelByIndex } from './game/levelLoader';

// Runtime mutable level state (module-level for now, will be moved to context)
let currentLevelIndex = 0;
let currentLevel = JSON.parse(JSON.stringify(LEVELS[currentLevelIndex].level));

export default function Game() {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const stateRef = useRef<GameState>('title');

  // expose a simple setter for manual testing from console
  (window as any).__setGameState = (s: GameState) => {
    stateRef.current = s;
  };

  useEffect(() => {
    // enter loading state and fetch assets for the current level
    stateRef.current = 'loading';
    let loadingCancelled = false;
    let loadedCount = 0;
    let totalToLoad = 0;
    let loadingProgress = 0;

    async function loadLevelAssets() {
      try {
        const meta: any = currentLevel.meta || {};
        const assets = meta.assets || [];
        if (!Array.isArray(assets) || assets.length === 0) {
          // no explicit assets: wait a small timeout so UI shows loading briefly
          // continue afterwards so other meta-driven resources (parallax, sfx)
          // still get a chance to load even when `meta.assets` is empty.
          await new Promise((r) => setTimeout(r, 500));
        }

        totalToLoad = assets.length;
        const promises = assets.map(async (a: string) => {
          // heuristic: image if png/jpg, audio if mp3/ogg/m4a
          const lower = a.toLowerCase();
          if (lower.endsWith('.png') || lower.endsWith('.jpg') || lower.endsWith('.jpeg') || lower.endsWith('.webp')) {
            await assetManager.loadImage(a);
          } else if (lower.endsWith('.mp3') || lower.endsWith('.ogg') || lower.endsWith('.m4a') || lower.endsWith('.wav')) {
            await assetManager.loadAudio(a);
          } else {
            // try image first
            await assetManager.loadImage(a).catch(() => assetManager.loadAudio(a).catch(() => { }));
          }
          loadedCount++;
          loadingProgress = totalToLoad > 0 ? loadedCount / totalToLoad : 1;
        });

        // race between asset loading and a max timeout so loading never blocks forever
        await Promise.race([Promise.all(promises), new Promise((r) => setTimeout(r, 2000))]);
        // Attempt to create SFX hooks from meta.sfx (silent/no-op on missing)
        try {
          const sfxMeta: any = meta.sfx || {};
          sfxJump = await audioManager.createSound(sfxMeta.jump || 'sfx/jump.mp3').catch(() => null);
          sfxLand = await audioManager.createSound(sfxMeta.land || 'sfx/land.mp3').catch(() => null);
          sfxCheckpoint = await audioManager.createSound(sfxMeta.checkpoint || 'sfx/checkpoint.mp3').catch(() => null);
          sfxDeath = await audioManager.createSound(sfxMeta.death || 'sfx/death.mp3').catch(() => null);
          sfxComplete = await audioManager.createSound(sfxMeta.complete || 'sfx/complete.mp3').catch(() => null);
        } catch (e) {
          // ignore — sounds will be null
        }
        // Load parallax layers from meta (optional) via helper
        try {
          const layersSpec: any[] = meta.parallax || meta.layers || [];
          const loaded = await loadParallaxLayers(assetManager, layersSpec);
          parallax.push(...loaded);
        } catch (e) {
          // ignore
        }
        // try load a player sprite sheet (optional)
        try {
          const pImg = await assetManager.loadImage('sprites/player.png').catch(() => null);
          if (pImg) {
            const sheet = createSpriteSheet(pImg, 32, 32);
            const base = new AnimatedSprite(sheet);
            base.addAnim('idle', [0], 6, true);
            const runFrames: number[] = [];
            for (let i = 1; i <= Math.min(4, sheet.frameCount - 1); i++) runFrames.push(i);
            if (runFrames.length > 0) base.addAnim('run', runFrames, 14, true);
            if (sheet.frameCount > 5) base.addAnim('jump', [5], 12, false);
            if (sheet.frameCount > 6) base.addAnim('fall', [6], 12, false);
            const entity = new AnimationStateMachine();
            entity.addLayer(base, { fallback: 'idle' }, 0, 0);
            // try load an accessory overlay (hat/gear) that aligns with same frames
            try {
              const acc = await assetManager.loadImage('sprites/player_hat.png').catch(() => null);
              if (acc) {
                const accSheet = createSpriteSheet(acc, 32, 32);
                const accSprite = new AnimatedSprite(accSheet);
                // mirror animations from base where possible
                accSprite.addAnim('idle', [0], 6, true);
                if (accSheet.frameCount > 1) {
                  const f: number[] = [];
                  for (let i = 1; i <= Math.min(4, accSheet.frameCount - 1); i++) f.push(i);
                  if (f.length) accSprite.addAnim('run', f, 14, true);
                }
                entity.addLayer(accSprite, { fallback: 'idle' }, 0, -8);
              }
            } catch (e) {
              /* ignore accessory */
            }
            playerEntity = entity;
          }
        } catch (e) {
          // ignore — sprite optional
        }
      } catch (e) {
        // ignore — fallthrough to title
      }
    }

    loadLevelAssets().then(() => {
      if (!loadingCancelled) stateRef.current = 'title';
    });

    // helper to load a level by pack index at runtime
    async function loadLevelByIndex(idx: number) {
      if (idx < 0 || idx >= LEVELS.length) return;
      currentLevelIndex = idx;
      currentLevel = JSON.parse(JSON.stringify(LEVELS[idx].level));
      // clear runtime assets/visuals that are level-specific
      parallax.length = 0;
      // reset checkpoint/start state for new level
      try {
        const startObjNew = (currentLevel.objects || []).find((o: any) => o.type === 'start');
        lastCheckpointX = startObjNew ? startObjNew.x : PLAYER_DEFAULTS.startX;
        reachedFinish = false;
      } catch (e) {
        // ignore
      }
      // attempt to load assets for the new level
      await loadLevelAssets();
      // respawn player at start/checkpoint of new level
      respawn();
      // briefly show restart hint so player knows R will restart
      restartHintTimer = 2.5;
    }

    // Audio unlock gate: unlock audio on first user gesture
    const unlockOnce = () => {
      audioManager.unlock().catch(() => { });
      window.removeEventListener('keydown', unlockOnce);
      window.removeEventListener('pointerdown', unlockOnce);
    };
    window.addEventListener('keydown', unlockOnce, { once: true });
    window.addEventListener('pointerdown', unlockOnce, { once: true });
    const canvasEl = canvasRef.current!;
    const ctx = canvasEl.getContext('2d')!;

    // virtual (offscreen) canvas at fixed virtual resolution
    const vcanvas = document.createElement('canvas');
    vcanvas.width = VIRTUAL_WIDTH;
    vcanvas.height = VIRTUAL_HEIGHT;
    const vctx = vcanvas.getContext('2d')!;
    // Create visual texture patterns using extracted functions
    const snowPattern = createSnowPattern(vctx);
    const noisePattern = createNoisePattern(vctx);

    // Initialize player and camera
    const initialPlayer: Player = createPlayer();
    const initialCam: Camera = { x: initialPlayer.x };

    // Initialize GameContext with all mutable game state
    const gameContext: GameContext = {
      state: stateRef.current,
      currentLevel,
      currentLevelIndex,

      currPlayer: initialPlayer,
      prevPlayer: { ...initialPlayer },
      currCam: initialCam,
      prevCam: { ...initialCam },

      lastGroundY: null,
      lastGroundAngle: 0,
      ledgeGrace: 0,

      lastSlope: 0,
      lastSlopeEff: 0,
      lastAccelRaw: 0,
      lastAccelScaled: 0,

      landingFlash: 0,
      crashFade: 0,
      crashTimer: 0,
      restartHintTimer: 0,
      fps: 60,

      spacePressSnapshot: null,
      jumpAppliedThisFrame: false,
      lastContactBack: null,
      lastContactFront: null,
      lastContactAvg: null,
      lastNearGround: false,
      pendingImmediateJump: false,

      lastNonEditorState: stateRef.current,
      editorStop: null,
      editorCamX: 0,
      editorCamY: 0,
      editorZoom: 1,
      lastEditorZoom: 1,

      parallax: [],
      effects: new EffectsManager({ enabled: true }),
      playerEntity: null,

      sfxJump: null,
      sfxLand: null,
      sfxCheckpoint: null,
      sfxDeath: null,
      sfxComplete: null,

      coyoteTimer: 0,
      jumpBuffer: 0,
      jumpHold: 0,
      jumpLock: 0,

      lastCheckpointX: ((currentLevel.objects || []).find((o: any) => o.type === 'start') as any)?.x ?? initialPlayer.x,
      reachedFinish: false,
      deathTimer: 0,

      snowPattern,
      noisePattern,

      accumulator: 0,
      lastTime: performance.now()
    };

    function respawn() {
      const rx = gameContext.lastCheckpointX ?? PLAYER_DEFAULTS.startX;
      gameContext.currPlayer.x = rx;
      const hy = getHeightAtX(gameContext.currentLevel as any, rx);
      // place player slightly above ground so feet sit on the surface rather than inside it
      const FEET_OFFSET = 8; // virtual pixels from contact height to player's origin
      gameContext.currPlayer.y = hy !== null ? hy - FEET_OFFSET : PLAYER_DEFAULTS.startY;
      gameContext.currPlayer.vx = PHYS.BASE_CRUISE_SPEED;
      gameContext.currPlayer.vy = 0;
      gameContext.currPlayer.angle = 0;
      // start slightly above ground and mark airborne so we don't snap into the ground
      gameContext.currPlayer.grounded = false;
      gameContext.currPlayer.wasGrounded = false;
      gameContext.lastGroundY = null;
      gameContext.currPlayer.invulnTimer = 1.0; // grant a short invulnerability window after respawn
      gameContext.prevPlayer = { ...gameContext.currPlayer };
      gameContext.currCam.x = gameContext.currPlayer.x;
      gameContext.prevCam = { ...gameContext.currCam };
      // resume play
      gameContext.state = 'playing';
      stateRef.current = 'playing';
      gameContext.reachedFinish = false;
      gameContext.deathTimer = 0;
    }

    // Developer test helper: trigger a crash/fall sequence programmatically
    function triggerCrash() {
      if (stateRef.current === 'dead') return;
      gameContext.state = 'dead';
      stateRef.current = 'dead';
      gameContext.crashFade = 0.6;
      gameContext.crashTimer = 0.9;
      void gameContext.sfxDeath?.play?.();
    }

    // Simulation wrapper: calls extracted simulate then updates camera
    function simulateStep(dt: number, input: InputManager) {
      // Call extracted simulation logic
      simulate(gameContext, dt, input);

      // Camera follows player with look-ahead and smoothing, clamped to level bounds
      const levelWidth = (gameContext.currentLevel.meta && gameContext.currentLevel.meta.width) || (gameContext.currentLevel.segments && gameContext.currentLevel.segments.length) || VIRTUAL_WIDTH;
      const look = Math.max(-CAMERA_SETTINGS.MAX_LOOK_AHEAD, Math.min(CAMERA_SETTINGS.MAX_LOOK_AHEAD, gameContext.currPlayer.vx * CAMERA_SETTINGS.LOOK_AHEAD_MULT));
      const targetCamX = gameContext.currPlayer.x + look;
      // Smooth toward target (frame-rate independent)
      const t = Math.min(1, CAMERA_SETTINGS.SMOOTH * dt);
      gameContext.currCam.x += (targetCamX - gameContext.currCam.x) * t;
      // Clamp so camera doesn't show past level edges
      const halfW = VIRTUAL_WIDTH / 2;
      const minCam = halfW;
      const maxCam = Math.max(halfW, levelWidth - halfW);
      gameContext.currCam.x = Math.max(minCam, Math.min(maxCam, gameContext.currCam.x));
      // Airborne rotation easing: when not grounded, ease angle toward neutral (0)
      if (!gameContext.currPlayer.grounded) {
        const ANGLE_EASE = 6; // higher = faster easing
        gameContext.currPlayer.angle += (0 - gameContext.currPlayer.angle) * Math.min(1, ANGLE_EASE * dt);
      }
    }

    // Draw wrapper: calls extracted draw function
    function drawGame() {
      draw(gameContext, vctx, canvasEl, ctx);
    }


    // layout setup
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvasEl.width = Math.round(window.innerWidth * dpr);
      canvasEl.height = Math.round(window.innerHeight * dpr);
      canvasEl.style.width = `${window.innerWidth}px`;
      canvasEl.style.height = `${window.innerHeight}px`;
      ctx.imageSmoothingEnabled = false;
      vctx.imageSmoothingEnabled = false;
    }

    resize();
    window.addEventListener('resize', resize);

    // input manager
    const input = new InputManager();
    input.start();

    // fixed timestep rAF loop
    let rafId = 0;
    gameContext.lastTime = performance.now();
    let lastGameState: GameState = stateRef.current;

    function loop(now: number) {
      // pause sim when page is hidden
      if (document.hidden) {
        lastTime = now;
        rafId = requestAnimationFrame(loop);
        return;
      }

      let delta = (now - lastTime) / 1000;
      if (delta > 0.25) delta = 0.25; // clamp to avoid spiral of death
      // update a smoothed FPS estimate
      if (delta > 0) fps += (1 / delta - fps) * 0.08;
      // decay landing flash timer
      landingFlash = Math.max(0, landingFlash - delta);
      // decay transient restart hint timer
      restartHintTimer = Math.max(0, (restartHintTimer || 0) - delta);
      // handle crash/death timers (fade only) even when not playing
      if (stateRef.current === 'dead') {
        if (crashTimer > 0) {
          crashTimer -= delta;
          crashFade = Math.max(0, crashFade - delta);
        } else {
          // no auto-respawn; wait for user to press `R` to respawn
        }
      }
      lastTime = now;
      accumulator += delta;
      // handle global input for state changes (pause, restart, start)
      const escPressed = input.get('Escape').wasPressed;
      const rPressed = input.get('r').wasPressed;
      const startPressed = input.get(' ').wasPressed;
      const crashKey = input.get('k').wasPressed;
      const ePressed = input.get('e').wasPressed;
      if (startPressed) {
        // Only capture a snapshot for missed-press handling when the player is
        // currently grounded. We shouldn't record a 'missed' press while
        // airborne because that would later trigger forced jumps incorrectly.
        if (currPlayer.grounded) {
          spacePressSnapshot = {
            t: performance.now(),
            state: stateRef.current,
            grounded: currPlayer.grounded,
            wasGrounded: currPlayer.wasGrounded,
            coyoteTimer,
            jumpBuffer,
            jumpLock,
            vy: currPlayer.vy,
            y: currPlayer.y,
          };
          // If we appear grounded now and contact samples from the last simulate show
          // we're near the ground, request an immediate jump to be applied inside
          // the next physics step to avoid missing the transient wasPressed edge.
          if (stateRef.current === 'playing' && spacePressSnapshot.grounded && jumpLock <= 0 && lastContactBack !== null && lastContactFront !== null && lastNearGround) {
            pendingImmediateJump = true;
            // eslint-disable-next-line no-console
            console.log('[jump-debug] requested pendingImmediateJump from main loop', { t: performance.now(), press: spacePressSnapshot });
          }
        }
      }
      if (rPressed) {
        // force respawn / restart
        respawn();
      }

      // dev test: press K to simulate a crash
      if (crashKey) triggerCrash();

      // toggle pause/resume
      if (escPressed) {
        if (stateRef.current === 'playing') stateRef.current = 'paused';
        else if (stateRef.current === 'paused') stateRef.current = 'playing';
      }

      // start from title
      if (stateRef.current === 'title' && startPressed) {
        respawn();
        stateRef.current = 'playing';
      }

      // continue to next level from complete when SPACE pressed
      if (stateRef.current === 'complete' && startPressed) {
        const nextIdx = currentLevelIndex + 1;
        if (nextIdx < LEVELS.length) {
          // show loading state while switching levels
          stateRef.current = 'loading';
          loadLevelByIndex(nextIdx).then(() => {
            // only resume play if still in loading state
            if (stateRef.current === 'loading') stateRef.current = 'playing';
          });
        } else {
          // no next level: restart current level
          respawn();
          stateRef.current = 'playing';
        }
      }

      // toggle editor state when compile-time enabled
      if (ePressed && typeof EDITOR_ENABLED !== 'undefined' && EDITOR_ENABLED) {
        if (stateRef.current !== 'editor') {
          lastNonEditorState = stateRef.current;
          stateRef.current = 'editor';
        } else {
          stateRef.current = lastNonEditorState || 'title';
        }
      }

      // detect simple game-state transitions and reset timing to avoid large accumulator
      if (lastGameState !== stateRef.current) {
        lastGameState = stateRef.current;
        // prevent interpolation artifacts by syncing snapshots
        prevPlayer = { ...currPlayer };
        prevCam = { ...currCam };
        accumulator = 0;
        lastTime = now;
        // start/stop editor when entering/exiting editor state
        try {
          const canvasElInner = canvasRef.current!;
          if (typeof EDITOR_ENABLED !== 'undefined' && EDITOR_ENABLED) {
            if (stateRef.current === 'editor') {
              if (!editorStop) {
                // initialize editor camera from gameplay cam/player
                editorCamX = currCam.x;
                editorCamY = currPlayer.y || VIRTUAL_HEIGHT / 2;
                editorZoom = lastEditorZoom || 1;
                canvasElInner.dataset.editorActive = '1';
                // screenToWorld maps client pixels -> virtual coords -> world coords
                const screenToWorldFn = (clientX: number, clientY: number) => {
                  // convert client -> virtual canvas coords (px,py)
                  const scale = Math.min(window.innerWidth / VIRTUAL_WIDTH, window.innerHeight / VIRTUAL_HEIGHT);
                  const destW = VIRTUAL_WIDTH * scale;
                  const destH = VIRTUAL_HEIGHT * scale;
                  const destX = (window.innerWidth - destW) / 2;
                  const destY = (window.innerHeight - destH) / 2;
                  const px = (clientX - destX) / scale;
                  const py = (clientY - destY) / scale;
                  // when in editor mode, convert virtual px/py -> world using editor cam + zoom
                  const wx = (px - VIRTUAL_WIDTH / 2) / editorZoom + editorCamX;
                  const wy = (py - VIRTUAL_HEIGHT / 2) / editorZoom + editorCamY;
                  return { x: wx, y: wy };
                };

                editorStop = startEditor({
                  canvas: canvasElInner,
                  screenToWorld: screenToWorldFn,
                  level: currentLevel as any,
                  onChange() {
                    // noop for now; could mark level dirty
                  },
                });

                // Export / Import UI (only present while editor active)
                const exportBtn = document.createElement('button');
                exportBtn.textContent = 'Export Level';
                exportBtn.style.position = 'fixed';
                exportBtn.style.right = '12px';
                exportBtn.style.bottom = '12px';
                exportBtn.style.zIndex = '9999';
                exportBtn.style.padding = '6px 8px';
                exportBtn.style.background = '#222';
                exportBtn.style.color = '#ffd700';
                document.body.appendChild(exportBtn);

                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = 'application/json';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                const importBtn = document.createElement('button');
                importBtn.textContent = 'Import Level';
                importBtn.style.position = 'fixed';
                importBtn.style.right = '120px';
                importBtn.style.bottom = '12px';
                importBtn.style.zIndex = '9999';
                importBtn.style.padding = '6px 8px';
                importBtn.style.background = '#222';
                importBtn.style.color = '#fff';
                document.body.appendChild(importBtn);

                const showError = (msg: string) => {
                  const el = document.createElement('div');
                  el.textContent = msg;
                  el.style.position = 'fixed';
                  el.style.left = '12px';
                  el.style.bottom = '12px';
                  el.style.background = 'rgba(0,0,0,0.8)';
                  el.style.color = '#fff';
                  el.style.padding = '8px 12px';
                  el.style.zIndex = '9999';
                  document.body.appendChild(el);
                  setTimeout(() => el.remove(), 4000);
                };

                exportBtn.addEventListener('click', () => {
                  try {
                    const dataStr = JSON.stringify(currentLevel, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = (currentLevel.meta && currentLevel.meta.title ? currentLevel.meta.title.replace(/[^a-z0-9]/gi, '_') : 'level') + '.json';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                  } catch (e) {
                    showError('Export failed');
                  }
                });

                importBtn.addEventListener('click', () => fileInput.click());
                fileInput.addEventListener('change', (ev) => {
                  const f = (ev.target as HTMLInputElement).files?.[0];
                  if (!f) return;
                  const reader = new FileReader();
                  reader.onload = () => {
                    try {
                      const parsed = JSON.parse(String(reader.result));
                      // TODO: migrateLevel if needed (not implemented yet)
                      const v = validateLevel(parsed as any);
                      if (!v.ok) { showError('Invalid level: ' + v.reason); return; }
                      // accept and replace current level
                      Object.assign(currentLevel, parsed);
                      showError('Level imported');
                    } catch (e) {
                      showError('Import failed');
                    }
                  };
                  reader.readAsText(f);
                });

                // drag & drop support
                const onDrop = (ev: DragEvent) => {
                  if (stateRef.current !== 'editor') return;
                  ev.preventDefault();
                  const f = ev.dataTransfer?.files?.[0];
                  if (!f) return;
                  const reader = new FileReader();
                  reader.onload = () => {
                    try {
                      const parsed = JSON.parse(String(reader.result));
                      const v = validateLevel(parsed as any);
                      if (!v.ok) { showError('Invalid level: ' + v.reason); return; }
                      Object.assign(currentLevel, parsed);
                      showError('Level imported');
                    } catch (e) {
                      showError('Import failed');
                    }
                  };
                  reader.readAsText(f);
                };
                const onDragOver = (ev: DragEvent) => { if (stateRef.current === 'editor') ev.preventDefault(); };
                window.addEventListener('drop', onDrop);
                window.addEventListener('dragover', onDragOver);

                // attach to editor handlers for cleanup
                (editorStop as any).__exportImportNodes = { exportBtn, importBtn, fileInput, onDrop, onDragOver };

                // wheel zoom handler (anchor zoom at cursor)
                const wheelHandler = (ev: WheelEvent) => {
                  if (stateRef.current !== 'editor') return;
                  ev.preventDefault();
                  // client -> virtual px/py
                  const scale = Math.min(window.innerWidth / VIRTUAL_WIDTH, window.innerHeight / VIRTUAL_HEIGHT);
                  const destW = VIRTUAL_WIDTH * scale;
                  const destH = VIRTUAL_HEIGHT * scale;
                  const destX = (window.innerWidth - destW) / 2;
                  const destY = (window.innerHeight - destH) / 2;
                  const px = (ev.clientX - destX) / scale;
                  const py = (ev.clientY - destY) / scale;
                  // world under cursor before zoom
                  const worldBeforeX = (px - VIRTUAL_WIDTH / 2) / editorZoom + editorCamX;
                  const worldBeforeY = (py - VIRTUAL_HEIGHT / 2) / editorZoom + editorCamY;
                  // delta from wheel: use exponential scale
                  const factor = Math.pow(1.1, -ev.deltaY / 100);
                  let newZoom = editorZoom * factor;
                  newZoom = Math.max(EDITOR_ZOOM_MIN, Math.min(EDITOR_ZOOM_MAX, newZoom));
                  // adjust camera so worldUnderCursor stays stable
                  editorCamX = worldBeforeX - (px - VIRTUAL_WIDTH / 2) / newZoom;
                  editorCamY = worldBeforeY - (py - VIRTUAL_HEIGHT / 2) / newZoom;
                  editorZoom = newZoom;
                  lastEditorZoom = editorZoom;
                };
                window.addEventListener('wheel', wheelHandler, { passive: false });

                // pointer pan handler (middle or right button drag)
                let panPointerId: number | null = null;
                let panLastPx = 0;
                let panLastPy = 0;
                const onPointerDownPan = (ev: PointerEvent) => {
                  if (stateRef.current !== 'editor') return;
                  if (ev.button !== 1 && ev.button !== 2) return; // middle or right
                  try { (ev.target as Element).setPointerCapture(ev.pointerId); } catch (e) { }
                  panPointerId = ev.pointerId;
                  const scale = Math.min(window.innerWidth / VIRTUAL_WIDTH, window.innerHeight / VIRTUAL_HEIGHT);
                  const destW = VIRTUAL_WIDTH * scale;
                  const destH = VIRTUAL_HEIGHT * scale;
                  const destX = (window.innerWidth - destW) / 2;
                  const destY = (window.innerHeight - destH) / 2;
                  panLastPx = (ev.clientX - destX) / scale;
                  panLastPy = (ev.clientY - destY) / scale;
                };
                const onPointerMovePan = (ev: PointerEvent) => {
                  if (stateRef.current !== 'editor') return;
                  if (panPointerId !== ev.pointerId) return;
                  const scale = Math.min(window.innerWidth / VIRTUAL_WIDTH, window.innerHeight / VIRTUAL_HEIGHT);
                  const destW = VIRTUAL_WIDTH * scale;
                  const destH = VIRTUAL_HEIGHT * scale;
                  const destX = (window.innerWidth - destW) / 2;
                  const destY = (window.innerHeight - destH) / 2;
                  const px = (ev.clientX - destX) / scale;
                  const py = (ev.clientY - destY) / scale;
                  const dx = px - panLastPx;
                  const dy = py - panLastPy;
                  panLastPx = px;
                  panLastPy = py;
                  // move editor cam by delta / zoom
                  editorCamX -= dx / editorZoom;
                  editorCamY -= dy / editorZoom;
                };
                const onPointerUpPan = (ev: PointerEvent) => {
                  if (panPointerId !== ev.pointerId) return;
                  panPointerId = null;
                  try { (ev.target as Element).releasePointerCapture(ev.pointerId); } catch (e) { }
                };
                canvasElInner.addEventListener('pointerdown', onPointerDownPan);
                window.addEventListener('pointermove', onPointerMovePan);
                window.addEventListener('pointerup', onPointerUpPan);

                // keydown handler for keyboard zoom/reset
                const keydownHandler = (ev: KeyboardEvent) => {
                  if (stateRef.current !== 'editor') return;
                  if (ev.key === '=' || ev.key === '+') {
                    let newZoom = Math.max(EDITOR_ZOOM_MIN, Math.min(EDITOR_ZOOM_MAX, editorZoom * 1.1));
                    editorZoom = newZoom; lastEditorZoom = editorZoom;
                  } else if (ev.key === '-') {
                    let newZoom = Math.max(EDITOR_ZOOM_MIN, Math.min(EDITOR_ZOOM_MAX, editorZoom / 1.1));
                    editorZoom = newZoom; lastEditorZoom = editorZoom;
                  } else if (ev.key === 'z') {
                    editorZoom = 1; lastEditorZoom = 1; editorCamX = currPlayer.x; editorCamY = currPlayer.y || VIRTUAL_HEIGHT / 2;
                  }
                };
                window.addEventListener('keydown', keydownHandler);

                // store these handlers on editorStop so we can remove them when stopping
                (editorStop as any).__editorHandlers = { wheelHandler, onPointerDownPan, onPointerMovePan, onPointerUpPan, keydownHandler };
              }
            } else {
              if (editorStop) {
                try { if (canvasRef.current) canvasRef.current.dataset.editorActive = '0'; } catch (e) { }
                // remove editor-specific handlers
                try {
                  const h = (editorStop as any).__editorHandlers;
                  if (h) {
                    window.removeEventListener('wheel', h.wheelHandler);
                    const canvasElInner2 = canvasRef.current!;
                    canvasElInner2.removeEventListener('pointerdown', h.onPointerDownPan);
                    window.removeEventListener('pointermove', h.onPointerMovePan);
                    window.removeEventListener('pointerup', h.onPointerUpPan);
                    if (h.keydownHandler) window.removeEventListener('keydown', h.keydownHandler);
                  }
                } catch (e) { }
                try {
                  const nodes = (editorStop as any).__exportImportNodes;
                  if (nodes) {
                    try { nodes.exportBtn.remove(); } catch (e) { }
                    try { nodes.importBtn.remove(); } catch (e) { }
                    try { nodes.fileInput.remove(); } catch (e) { }
                    try { window.removeEventListener('drop', nodes.onDrop); } catch (e) { }
                    try { window.removeEventListener('dragover', nodes.onDragOver); } catch (e) { }
                  }
                } catch (e) { }
                try { editorStop(); } catch (e) { }
                editorStop = null;
              }
            }
          }
        } catch (e) {
          // ignore editor start errors
        }
      }

      if (stateRef.current === 'playing') {
        while (accumulator >= FIXED_DT) {
          // advance snapshots
          prevPlayer = { ...currPlayer };
          gameContext.prevCam = { ...gameContext.currCam };
          // reset jump-applied marker for this fixed-step batch
          gameContext.jumpAppliedThisFrame = false;
          // You can query input here per-step if needed, e.g. input.get(' ')
          simulateStep(FIXED_DT, input);
          gameContext.accumulator -= FIXED_DT;
        }
      } else {
        // not playing: don't advance sim; clamp accumulator so alpha stays sensible
        accumulator = 0;
      }

      drawGame();
      // editor keyboard pan/zoom handling
      if (stateRef.current === 'editor') {
        const basePanSpeed = 180; // world units per second
        const panSpeed = basePanSpeed * Math.min(0.033, delta) / Math.max(0.0001, editorZoom);
        if (input.get('w').isDown || input.get('ArrowUp').isDown) editorCamY -= panSpeed;
        if (input.get('s').isDown || input.get('ArrowDown').isDown) editorCamY += panSpeed;
        if (input.get('a').isDown || input.get('ArrowLeft').isDown) editorCamX -= panSpeed;
        if (input.get('d').isDown || input.get('ArrowRight').isDown) editorCamX += panSpeed;
        // keyboard zoom handled via keydown listener attached when editor starts
      }

      // if space was pressed this frame but no jump was applied during simulation, log detailed snapshot
      if (spacePressSnapshot && !jumpAppliedThisFrame) {
        // eslint-disable-next-line no-console
        console.log('[jump-debug] SPACE pressed but no jump applied', {
          press: spacePressSnapshot,
          now: performance.now(),
          grounded: currPlayer.grounded,
          wasGrounded: currPlayer.wasGrounded,
          lastGroundY,
          ledgeGrace,
          jumpLock,
          coyoteTimer,
          jumpBuffer,
          vy: currPlayer.vy,
          y: currPlayer.y,
          // additional diagnostics: contact samples and whether input still reports wasPressed
          contactBack: lastContactBack,
          contactFront: lastContactFront,
          contactAvg: lastContactAvg,
          contactExists: lastContactBack !== null && lastContactFront !== null,
          nearGround: lastNearGround,
          inputWasPressedNow: input.get(' ').wasPressed,
        });
      }
      // clear per-frame transient input flags
      input.clearTransient();
      // reset snapshot and applied flag after handling
      spacePressSnapshot = null;
      jumpAppliedThisFrame = false;
      rafId = requestAnimationFrame(loop);
    }

    rafId = requestAnimationFrame(loop);

    return () => {
      window.removeEventListener('resize', resize);
      input.stop();
      cancelAnimationFrame(rafId);
    };
  }, []);

  return <canvas ref={canvasRef} style={{ position: 'fixed', left: 0, top: 0, width: '100%', height: '100%' }} />;
}
